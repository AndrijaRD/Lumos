#include "./TM.h"
#include "../System/Sys.h"



static int trailing_zeros_u32(uint32_t x) { return __builtin_ctz(x); }


/* TEXTURE DATA FUNCTIONS AND DEFINITIONS */

void TextureData::reloadInfo(){
    if (!dptr_->texture) {
        dptr_->format = TextureData::defaultPixelFormat;
        dptr_->access = TextureData::defaultAccess;
        dptr_->width = 0;
        dptr_->height = 0;
    } else {
        SDL_PropertiesID prop;
        prop = SDL_GetTextureProperties(dptr_->texture);

        dptr_->width = (int)SDL_GetNumberProperty(
            prop,
            SDL_PROP_TEXTURE_WIDTH_NUMBER,
            0
        );

        dptr_->height = (int)SDL_GetNumberProperty(
            prop,
            SDL_PROP_TEXTURE_HEIGHT_NUMBER,
            0
        );

        dptr_->access = (SDL_TextureAccess)SDL_GetNumberProperty(
            prop,
            SDL_PROP_TEXTURE_ACCESS_NUMBER,
            0
        );

        dptr_->format = (SDL_PixelFormat)SDL_GetNumberProperty(
            prop,
            SDL_PROP_TEXTURE_FORMAT_NUMBER,
            0
        );

    }
}

void TextureData::setTexture(SDL_Texture* newTex){
    // if we already had one, and no other Impl is holding it, free it:
    if (dptr_->texture) {
        bool otherAlive = false;
        for (auto &wk : TM::loadedTextures) {
            if (auto sp = wk.lock()) {
                if (sp.get() != dptr_.get() && sp->texture == dptr_->texture) {
                    otherAlive = true;
                    break;
                }
            }
        }
        if (!otherAlive) {
            if (TM::AUTO_DELETE_TEXTURES)
                SDL_DestroyTexture(dptr_->texture);
            else
                TM::outOfScopeTextures.push_back(dptr_->texture);
        }
    }

    dptr_->texture = newTex;

    // immediately re‑query its properties:
    reloadInfo();
}

TextureData::~TextureData(){
    if (dptr_.unique()) {
        if (dptr_->texture) {
            SDL_DestroyTexture(dptr_->texture);
            dptr_->texture = nullptr;
        }
        TM::removeTexture(dptr_);
    }
}

TextureData::TextureData(): dptr_(std::make_shared<Impl>())
{
    // give it a default autogenerated id if you like:
    id = "Empty";
    TM::registerTexture(dptr_);
}

void TextureData::printf(bool full) const {
    cout << "TextureData(" << endl;
    cout << "\t" << "Texture: " << dptr_->texture << endl;
    cout << "\t" << "Width: " << dptr_->width << endl;
    cout << "\t" << "Height: " << dptr_->height << endl;
    cout << "\t" << "ID: " << id << endl;
    if(full){
        cout << "\t" << "Format: " << dptr_->format << endl;
        cout << "\t" << "Access: " << dptr_->access << endl;
        cout << "\t" << "OrgWidth: " << orgWidth << endl;
        cout << "\t" << "OrgHeight: " << orgHeight << endl;
    }
    cout << ");" << endl;
}


/* BASIC TEXTURE MANAGER PRIVATE/SETTINGS FUNCTIONS */

void TM::registerTexture(std::shared_ptr<TextureData::Impl> const& ptr) {
    loadedTextures.push_back(ptr);
}


void TM::removeTexture(std::shared_ptr<TextureData::Impl> dead) {
    auto &v = loadedTextures;
    v.erase(
      std::remove_if(v.begin(), v.end(),
        [&](auto &wk){
          auto sp = wk.lock();
          // remove if expired OR matches the one we’re removing:
          return !sp || sp == dead;
        }
      ),
      v.end()
    );
}


void TM::setAutoDeleteTextures(bool prop){ AUTO_DELETE_TEXTURES = prop; }




///////////////////////////////////////////////////////////////////////////////////////////

int ensureSurfaceFormat(SDL_Surface*& surface) {
    if (surface->format != SDL_PIXELFORMAT_RGBA32) {
        SDL_Surface* conv = SDL_ConvertSurface(surface, SDL_PIXELFORMAT_RGBA32);
        SDL_DestroySurface(surface);
        if (!conv) {
            return TM_SURFACE_CONVERT_ERROR;
        }
        surface = conv;
    }
    return NO_ERROR;
}


// Rotate src (by reference) in‐place to 90°/180°/270°.
// After the call, src points at a brand‐new surface (old is destroyed).
// Returns NO_ERROR on success.
int rotateSurface(SDL_Surface*& src, int angle) {
    if (!src) return INVALID_ARGUMENTS_PASSED;
    // Only multiples of 90°
    angle = ((angle % 360) + 360) % 360;
    if (angle != 90 && angle != 180 && angle != 270) {
        return INVALID_ARGUMENTS_PASSED;
    }

    // Ensure we work in RGBA32
    if (src->format != SDL_PIXELFORMAT_RGBA32) {
        SDL_Surface* conv = SDL_ConvertSurface(src, SDL_PIXELFORMAT_RGBA32);
        SDL_DestroySurface(src);
        if (!conv) return TM_SURFACE_CONVERT_ERROR;
        src = conv;
    }

    int w = src->w, h = src->h;
    int dw = (angle == 180 ? w : h);
    int dh = (angle == 180 ? h : w);

    // Create the destination surface
    SDL_Surface* dst = SDL_CreateSurface(dw, dh, SDL_PIXELFORMAT_RGBA32);
    if (!dst) return TM_SURFACE_CREATE_ERROR;

    // Pointers & strides in pixels
    Uint32* sp = (Uint32*)src->pixels;
    Uint32* dp = (Uint32*)dst->pixels;
    int  s_stride = src->pitch   / sizeof(Uint32);
    int  d_stride = dst->pitch   / sizeof(Uint32);

    // Choose the right copy loop with no per-pixel if's
    if (angle == 90) {
        // (y, x) → (x, h-1-y)
        for (int y = 0; y < h; ++y) {
            Uint32* srow = sp + y * s_stride;
            int invY = h - 1 - y;
            for (int x = 0; x < w; ++x) {
                dp[x * d_stride + invY] = srow[x];
            }
        }
    }
    else if (angle == 180) {
        // (y, x) → (h-1-y, w-1-x)
        for (int y = 0, yy = h-1; y < h; ++y, --yy) {
            Uint32* srow = sp + y * s_stride;
            Uint32* drow = dp + yy * d_stride;
            for (int x = 0, xx = w-1; x < w; ++x, --xx) {
                drow[xx] = srow[x];
            }
        }
    }
    else { // angle==270
        // (y, x) → (w-1-x, y)
        for (int y = 0; y < h; ++y) {
            Uint32* srow = sp + y * s_stride;
            for (int x = 0; x < w; ++x) {
                dp[(w - 1 - x) * d_stride + y] = srow[x];
            }
        }
    }

    // Swap out the surfaces
    SDL_DestroySurface(src);
    src = dst;
    return NO_ERROR;
}





///////////////////////////////////////////////////////////////////////////////////////////









SDL_Texture* SVGIcon::getIcon(int size){
    auto it = sizes.find(size);
    if (it != sizes.end()) {
        // found: return existing texture
        return it->second;
    }

    // not found: create
    SDL_Texture* tex = loadSize(size);
    if (!tex) {
        // creation failed — handle appropriately
        return nullptr;
    }

    sizes.emplace(size, tex); // inserts (key, value) without copying
    return tex;
}

SDL_Texture* SVGIcon::loadSize(int size){
    cout << "LOADING SVG INTO SPECIFIC SIZE!" << endl;
    const int stride_bytes = size * 4;
    unsigned char *rgba = (unsigned char*)malloc(size * size * 4);
    if (!rgba) { 
        std::fprintf(stderr,"malloc failed\n"); 
        return nullptr;
    }
    memset(rgba, 0, size * size * 4);

    // Fit SVG into icon size keeping aspect ratio
    float scaleX = (float)size / image->width;
    float scaleY = (float)size / image->height;
    float scale = (scaleX < scaleY) ? scaleX : scaleY;
    float tx = (size - image->width * scale) * 0.5f;
    float ty = (size - image->height * scale) * 0.5f;

    nsvgRasterize(TM::rast, image, tx, ty, scale, rgba, size, size, stride_bytes);

    // Convert to platform's RGBA8888 order + premultiplied alpha
    int bpp;
    Uint32 rmask, gmask, bmask, amask;
    if (!SDL_GetMasksForPixelFormat(SDL_PIXELFORMAT_RGBA8888, &bpp, &rmask, &gmask, &bmask, &amask)) {
        std::fprintf(stderr, "SDL_GetMasksForPixelFormat failed\n");
        return nullptr;
    }

    int rshift = trailing_zeros_u32(rmask);
    int gshift = trailing_zeros_u32(gmask);
    int bshift = trailing_zeros_u32(bmask);
    int ashift = trailing_zeros_u32(amask);


    uint32_t *pixels = (uint32_t*)malloc(size * size * sizeof(uint32_t));
    if (!pixels) { 
        std::fprintf(stderr,"malloc pixels failed\n"); 
        return nullptr;
    }

    for (int y = 0; y < size; ++y) {
        for (int x = 0; x < size; ++x) {
            int i = (y * size + x) * 4;
            unsigned int r = rgba[i + 0];
            unsigned int g = rgba[i + 1];
            unsigned int b = rgba[i + 2];
            unsigned int a = rgba[i + 3];

            // Premultiply (rounding)
            unsigned int rp = (r * a + 127) / 255;
            unsigned int gp = (g * a + 127) / 255;
            unsigned int bp = (b * a + 127) / 255;

            uint32_t pixel = ( (uint32_t)rp << rshift ) |
                                ( (uint32_t)gp << gshift ) |
                                ( (uint32_t)bp << bshift ) |
                                ( (uint32_t)a  << ashift );
            pixels[y * size + x] = pixel;
        }
    }

    // Create texture and upload (pitch in bytes)
    SDL_Texture *tex = SDL_CreateTexture(Sys::renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_STATIC, size, size);
    if (!tex) { 
        std::fprintf(stderr,"SDL_CreateTexture: %s\n", SDL_GetError()); 
        return nullptr;
    }

    if (!SDL_UpdateTexture(tex, NULL, pixels, size * 4)) {
        std::fprintf(stderr, "SDL_UpdateTexture: %s\n", SDL_GetError());
        return nullptr;
    }

    // premultiplied blend mode + linear filter
    SDL_SetTextureScaleMode(tex, SDL_SCALEMODE_LINEAR);
    SDL_BlendMode premBlend = SDL_ComposeCustomBlendMode(
        SDL_BLENDFACTOR_ONE, SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA, SDL_BLENDOPERATION_ADD,
        SDL_BLENDFACTOR_ONE, SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA, SDL_BLENDOPERATION_ADD
    );
    SDL_SetTextureBlendMode(tex, premBlend);

    // free CPU copies
    free(pixels);
    free(rgba);
    nsvgDelete(image);

    return tex;
}














/////////////////////////////////////////////////////////////////////////////////////////

int TM::loadTexture(
    TextureData&        td, 
    const string&       path, 
    const string&       id
){
    // Just in case there was something in the td object, free it ---------------------------------
    td.setTexture(nullptr);

    // Load the image -----------------------------------------------------------------------------
    SDL_Surface* surface = IMG_Load(path.c_str());
    if(surface == nullptr) return TM_SURFACE_CREATE_ERROR;

    // Check the format of the image --------------------------------------------------------------
    int errorCode = ensureSurfaceFormat(surface);
    if(errorCode) return errorCode;

    SDL_Texture* tex;
    convert_toTexture(surface, tex);

    // Set the texture ----------------------------------------------------------------------------
    td.setTexture(tex);

    // GET TEXTURE DIMENSIONS ---------------------------------------------------------------------
    td.reloadInfo();
    td.orgWidth = td.getWidth();
    td.orgHeight = td.getHeight();

    // FILL TD DATA -------------------------------------------------------------------------------
    td.path = path;
    if(id.empty()) td.id = fs::path(path).filename().string();
    else td.id = id;

    // CLEAN UP ---------------------------------------------------------------------------
    SDL_DestroySurface(surface);

    return NO_ERROR;
}



int TM::loadSVG(
    SVGIcon&            svgIcon,
    const string&       path
){
    svgIcon.image = nsvgParseFromFile(path.c_str(), "px", 96.0f);
    if (!svgIcon.image) { 
        fprintf(stderr, "nsvgParseFromFile failed: %s\n", path.c_str());
        return 1; 
    }

    svgIcon.path = path;

    return 0;
}



int TM::createTextTexture(
    TextureData&        td,
    const string&       text,
    int                 fontSize,
    SDL_Color           color
) {
    if(Sys::fontPath == "") {
        CHECK_ERROR(SYS_FONT_NOT_INITED);
        exit(EXIT_FAILURE);
    }

    // Ensure that privous Texture is de-loaded -----------------------------------------
    td.setTexture(nullptr);

    // Get the font with that particular fontSize
    TTF_Font* font = Sys::getFont(fontSize);

    // Create the text texture and store it as surface ----------------------------------
    int len = static_cast<int>(text.size());
    SDL_Surface* surface = TTF_RenderText_Blended(
        font, 
        text.c_str(), 
        len, 
        color
    );
    if(surface == nullptr) return TM_SURFACE_CREATE_ERROR;

    int errorCode = ensureSurfaceFormat(surface);
    if(errorCode) return errorCode;

    // Create texture from it and store it in TextureData
    SDL_Texture* tex;
    convert_toTexture(surface, tex);

    td.path = "TEXT";
    td.id = "TEXT-" + text;

    // SET THE TEXTURE --------------------------------------------------------------------
    td.setTexture(tex);

    // GET TEXTURE DIMENSIONS -------------------------------------------------------------
    td.reloadInfo();
    td.orgWidth = td.getWidth();
    td.orgHeight = td.getHeight();

    SDL_DestroySurface(surface);

    return NO_ERROR;
}



int TM::copyTexture(
    const TextureData&  src, 
    TextureData&        dst
) {
    // Check for valid pointers.
    if (!src.getTexture()) {
        return INVALID_ARGUMENTS_PASSED;
    }

    // Create a new texture with the same format, access and dimensions as src.
    SDL_Texture* newTex = SDL_CreateTexture(
        Sys::renderer,
        src.getFormat(),
        src.getAccess(),
        src.getWidth(),
        src.getHeight()
    );
    if(!newTex) return TM_TEXTURE_CREATE_ERROR;

    // Capture the previous target
    auto old_renderTarget = SDL_GetRenderTarget(Sys::renderer);

    // Set the new texture as the render target.
    bool err = SDL_SetRenderTarget(Sys::renderer, newTex);
    if (!err) {
        SDL_DestroyTexture(newTex);
        return TM_SRT_FAILED; // Set Render Target FAILED.
    }

    // Clear the render target (fill with blue)
    SDL_SetRenderDrawColor(Sys::renderer, 0, 0, 0, 0);
    SDL_RenderClear(Sys::renderer);

    // Copy the source texture onto the new texture.
    err = SDL_RenderTexture(
        Sys::renderer, 
        src.getTexture(), 
        nullptr, 
        nullptr
    );
    if (!err) {
        SDL_SetRenderTarget(Sys::renderer, old_renderTarget);
        SDL_DestroyTexture(newTex);
        return TM_RCPY_FAILED; // Render Copy FAILED
    }

    // Reset the render target back to the default
    SDL_SetRenderTarget(Sys::renderer, old_renderTarget);

    // Set Scale Mode for the Texture -------------------------------------------------------------
    err = SDL_SetTextureScaleMode(newTex, SDL_SCALEMODE_LINEAR);
    if(!err){
        SDL_DestroyTexture(newTex);
        return TM_STSM_FAILED;
    }

    // Make texture Updatable/Modifiable ----------------------------------------------------------
    err = SDL_SetTextureBlendMode(newTex, SDL_BLENDMODE_BLEND);
    if(!err){
        SDL_DestroyTexture(newTex);
        return TM_TEXTURE_SET_BLENDMODE_ERROR;
    }

    // Use the destination object's setTexture method to update its texture.
    dst.setTexture(newTex);

    // Copy metadata from src to dst.
    dst.reloadInfo();
    dst.orgWidth  = src.orgWidth;
    dst.orgHeight = src.orgHeight;
    dst.path      = src.path;
    dst.id        = src.id + "_copy";

    return NO_ERROR; // Success.

}


int TM::resizeTexture(
    const TextureData&  src,
    TextureData&        dst,
    int&                newWidth,
    int&                newHeight
){
    if (!src.getTexture()) 
        return INVALID_ARGUMENTS_PASSED;

    if (newWidth == -1 && newHeight == -1) 
        return INVALID_ARGUMENTS_PASSED;

    // Use original dimensions to compute aspect ratio.
    // Assume that td->orgWidth and td->orgHeight hold the original dimensions.
    if (newWidth == -1 && newHeight != -1) {
        newWidth = (newHeight * src.orgWidth) / src.orgHeight;
    } 
    else if (newHeight == -1 && newWidth != -1) {
        newHeight = (newWidth * src.orgHeight) / src.orgWidth;
    }

    // Create a new texture with the same format and access as the source.
    SDL_Texture* newTex = SDL_CreateTexture(
        Sys::renderer,
        src.getFormat(),
        src.getAccess(),
        newWidth,
        newHeight
    );
    if (!newTex) return TM_TEXTURE_CREATE_ERROR;

    // Set Scale Mode for the Texture -------------------------------------------------------------
    bool err = SDL_SetTextureScaleMode(newTex, SDL_SCALEMODE_LINEAR);
    if(!err){
        SDL_DestroyTexture(newTex);
        return TM_STSM_FAILED;
    }

    // Make texture Updatable/Modifiable ----------------------------------------------------------
    err = SDL_SetTextureBlendMode(newTex, SDL_BLENDMODE_BLEND);
    if(!err){
        SDL_DestroyTexture(newTex);
        return TM_TEXTURE_SET_BLENDMODE_ERROR;
    }

    // Capture the previous target
    auto old_renderTarget = SDL_GetRenderTarget(Sys::renderer);

    // Set the new texture as the render target.
    err = SDL_SetRenderTarget(Sys::renderer, newTex);
    if (!err) {
        SDL_DestroyTexture(newTex);
        return TM_SRT_FAILED; // Set Render Target FAILED
    }

    // Clear the new texture (fill with blue).
    SDL_SetRenderDrawColor(Sys::renderer, 0, 0, 0, 0);
    SDL_RenderClear(Sys::renderer);

    // Copy from the source texture to the new texture.
    // SDL_RenderCopy will scale the source to fit the destination rectangle.
    SDL_FRect dstRect = { 
        0, 
        0, 
        static_cast<float>(newWidth), 
        static_cast<float>(newHeight)
    };
    err = SDL_RenderTexture(
        Sys::renderer, 
        src.getTexture(), 
        nullptr, 
        &dstRect
    );
    if (!err) {
        SDL_SetRenderTarget(Sys::renderer, old_renderTarget);
        SDL_DestroyTexture(newTex);
        return TM_RCPY_FAILED; // Render Copy FAILED
    }

    // Reset the render target back to the default
    SDL_SetRenderTarget(Sys::renderer, old_renderTarget);

    // Update the TextureData object with the new texture and dimensions.
    dst.setTexture(newTex);
    dst.reloadInfo();

    return NO_ERROR;
}


// OVERLOAD
int TM::resizeTexture(
    const TextureData&  src,
    TextureData&        dst,
    const int&          newWidth,
    const int&          newHeight
){
    int newW = newWidth;
    int newH = newHeight;
    return resizeTexture(src, dst, newW, newH);
}


int TM::rotateTexture(
    const TextureData&  src,
    TextureData&        dst,
    int                 angle
) {
    // 1) Validate inputs
    SDL_Texture* srcTex = src.getTexture();
    if (!srcTex || !Sys::renderer) {
        return INVALID_ARGUMENTS_PASSED;      // no source texture or renderer
    }
    if (angle !=  90 && angle != 180 && angle != 270) {
        return INVALID_ARGUMENTS_PASSED;        // only 90/180/270 allowed
    }

   
    SDL_Surface* surface;
    int errorCode = TM::convert_textureTo(src, surface);
    if(errorCode) return errorCode;

    errorCode = ensureSurfaceFormat(surface);
    if(errorCode) return errorCode;

    errorCode = rotateSurface(surface, angle);
    if(errorCode) return errorCode;

    SDL_Texture* newTex;
    errorCode = TM::convert_toTexture(surface, newTex);
    if(errorCode) return errorCode;

    // 5) Attach to dst TextureData and update metadata
    dst.setTexture(newTex);
    dst.reloadInfo();
    dst.orgWidth  = dst.getWidth();
    dst.orgHeight = dst.getHeight();

    return NO_ERROR;
}



int TM::cropTexture(
    const TextureData& src,
    TextureData&       dst,
    SDL_Rect           rect
) {
    // 1) Validate inputs
    SDL_Texture* srcTex = src.getTexture();
    if (!srcTex || !Sys::renderer) {
        return INVALID_ARGUMENTS_PASSED;
    }

    // Ensure the crop rect lies within the source dimensions
    if (rect.x < 0 || rect.y < 0
     || rect.x + rect.w > src.getWidth()
     || rect.y + rect.h > src.getHeight()
     || rect.w <= 0 || rect.h <= 0)
    {
        return TM_INVALID_DRECT;
    }

    // 2) Create a new render‐target texture of the crop size,
    //    matching the source’s pixel format
    SDL_Texture* newTex = SDL_CreateTexture(
        Sys::renderer,
        src.getFormat(),
        TextureData::defaultAccess,
        rect.w,
        rect.h
    );
    if (!newTex) return TM_TEXTURE_CREATE_ERROR;
    

    // Set Scale Mode for the Texture -------------------------------------------------------------
    bool err = SDL_SetTextureScaleMode(newTex, SDL_SCALEMODE_LINEAR);
    if(!err){
        SDL_DestroyTexture(newTex);
        return TM_STSM_FAILED;
    }

    // Make texture Updatable/Modifiable ----------------------------------------------------------
    err = SDL_SetTextureBlendMode(newTex, SDL_BLENDMODE_BLEND);
    if(!err){
        SDL_DestroyTexture(newTex);
        return TM_TEXTURE_SET_BLENDMODE_ERROR;
    }



    // 3) Render the specified region into the new texture
    SDL_Texture* oldTarget = SDL_GetRenderTarget(Sys::renderer);
    err = SDL_SetRenderTarget(Sys::renderer, newTex);
    if (!err) {
        SDL_DestroyTexture(newTex);
        return TM_SRT_FAILED;
    }


    // Convert integer SDL_Rect to floating‐point SDL_FRect for SDL_RenderCopyEx
    SDL_FRect srcF = {
        float(rect.x),
        float(rect.y),
        float(rect.w),
        float(rect.h)
    };
    SDL_FRect dstF = {
        0.0f,
        0.0f,
        float(rect.w),
        float(rect.h)
    };

    // Copy that region (no rotation, no flip)
    SDL_RenderTextureRotated(
        Sys::renderer,
        srcTex,
        &srcF,
        &dstF,
        0.0,           // angle
        nullptr,       // center not used
        SDL_FLIP_NONE
    );

    // Restore previous render‐target
    SDL_SetRenderTarget(Sys::renderer, oldTarget);

    // 4) Attach the new texture to dst and update its metadata
    dst.setTexture(newTex);
    dst.reloadInfo();
    dst.orgWidth  = dst.getWidth();
    dst.orgHeight = dst.getHeight();

    return NO_ERROR;
}


int TM::transformTexture(
    const TextureData&  src,
    TextureData&        dst,
    PixelMapper           pixelFunc
) {

    if (!Sys::renderer || !src.getTexture())
        return INVALID_ARGUMENTS_PASSED;

    SDL_Surface* surf;
    if (int ec = TM::convert_textureTo(src, surf)) return ec;
    if (int ec = ensureSurfaceFormat(surf))     return ec;

    const int w     = surf->w;
    const int h     = surf->h;
    const int pitch = surf->pitch;  // bytes per row
    auto pixels     = static_cast<uint8_t*>(surf->pixels);

    SDL_LockSurface(surf);
    for (int y = 0; y < h; ++y) {
        uint8_t* row = pixels + y * pitch;
        for (int x = 0; x < w; ++x) {
            uint8_t* pxBase = row + x*4;
            uint8_t  r      = pxBase[0];
            uint8_t  g      = pxBase[1];
            uint8_t  b      = pxBase[2];
            uint8_t  a      = pxBase[3];

            SDL_Color out = pixelFunc(r, g, b, a);

            // clamp just in case
            pxBase[0] = static_cast<uint8_t>(std::clamp<int>(out.r, 0, 255));
            pxBase[1] = static_cast<uint8_t>(std::clamp<int>(out.g, 0, 255));
            pxBase[2] = static_cast<uint8_t>(std::clamp<int>(out.b, 0, 255));
            pxBase[3] = static_cast<uint8_t>(std::clamp<int>(out.a, 0, 255));
        }
    }
    SDL_UnlockSurface(surf);

    SDL_Texture* newTex;
    TM::convert_toTexture(surf, newTex);
    dst.setTexture(newTex);
    dst.reloadInfo();
    dst.orgWidth  = dst.getWidth();
    dst.orgHeight = dst.getHeight();
    return NO_ERROR;
}


int TM::exportTexture(
    const std::string&  path, 
    const TextureData&  td
) {
    if (!td.getTexture() || !Sys::renderer) return INVALID_ARGUMENTS_PASSED;
    return exportTexture(path, td.getTexture());
}

int TM::exportTexture(
    const std::string&  path, 
    SDL_Texture*  tex
) {
    if (tex == nullptr || !Sys::renderer) return -1;

    SDL_Surface* surface;
    convert_textureTo(tex, surface);

    // 4) Save to PNG
    bool err = IMG_SavePNG(surface, path.c_str());
    if (!err) {
        SDL_DestroySurface(surface);
        return UNKNOWN_ERROR;
    }

    // 5) Cleanup
    SDL_DestroySurface(surface);
    return NO_ERROR;
}



int TM::exportSurface(
    const std::string&  path, 
    SDL_Surface*        surface
) {
    // Check if the provided surface pointer is valid.
    if (surface == nullptr) return INVALID_ARGUMENTS_PASSED;

    // Attempt to save the surface to a PNG file at the specified path.
    bool err = IMG_SavePNG(surface, path.c_str());
    if (!err) return UNKNOWN_ERROR;

    // Operation succeeded.
    return NO_ERROR;
}






int TM::convert_toTexture(
    const cv::Mat&      cvMat, 
    TextureData&        td
){
    if(cvMat.channels() != 4) return TM_MAT_INVALID_FORMAT;
    if (cvMat.type() != CV_8UC4) return TM_MAT_INVALID_FORMAT;


    SDL_Texture* tex = SDL_CreateTexture(
        Sys::renderer,
        TextureData::defaultPixelFormat,    // RGBA order, 8 bits per channel
        TextureData::defaultAccess,         // one-time updates
        cvMat.cols,                         // width
        cvMat.rows                          // height
    );

    if (!tex) return TM_TEXTURE_CREATE_ERROR;



    // 3) Upload the OpenCV buffer directly into the texture.
    //    cvMat.step is the number of bytes per row in memory.
    bool err = SDL_UpdateTexture(
        tex,
        nullptr,                 // entire texture
        cvMat.data,
        static_cast<int>(cvMat.step)
    );

    if (!err){
        SDL_DestroyTexture(tex);
        return TM_TEXTURE_UPDATE_ERROR;
    }

    // Set Scale Mode for the Texture -------------------------------------------------------------
    err = SDL_SetTextureScaleMode(tex, SDL_SCALEMODE_LINEAR);
    if(!err){
        SDL_DestroyTexture(tex);
        return TM_STSM_FAILED;
    }

    // Make texture Updatable/Modifiable ----------------------------------------------------------
    err = SDL_SetTextureBlendMode(tex, SDL_BLENDMODE_BLEND);
    if(!err){
        SDL_DestroyTexture(tex);
        return TM_TEXTURE_SET_BLENDMODE_ERROR;
    }

    // Store the texture
    td.setTexture(tex);

    // Retrieve texture dimensions.
    td.reloadInfo();
    td.orgWidth = td.getWidth();
    td.orgHeight = td.getHeight();

    return NO_ERROR;
}



int TM::convert_textureTo(
    const TextureData&  td, 
    cv::Mat&            cvMat
){
    // 1) Validate inputs
    if (!td.getTexture() || !Sys::renderer) {
        return INVALID_ARGUMENTS_PASSED;
    }
    
    SDL_Surface* surf;
    int errorCode = convert_textureTo(td, surf);
    if(errorCode) return errorCode;

    errorCode = ensureSurfaceFormat(surf);
    if(errorCode) return errorCode;

    // 6) Allocate/resize the cv::Mat to match
    cvMat.create(surf->h, surf->w, CV_8UC4);

    // 7) Copy row by row (pitch may exceed width*4 bytes)
    int rowBytes = surf->w * 4;
    for (int y = 0; y < surf->h; ++y) {
        std::memcpy(
            cvMat.ptr(y),
            static_cast<uint8_t*>(surf->pixels) + y * surf->pitch,
            rowBytes
        );
    }

    // 8) Clean up
    SDL_DestroySurface(surf);
    return NO_ERROR;
}






int TM::convert_toTexture(
    const SDL_Surface*  surface, 
    TextureData&        td
){
    td.setTexture(nullptr);

    SDL_Texture* tex;
    convert_toTexture(surface, tex);

    td.setTexture(tex);
    td.reloadInfo();

    return NO_ERROR;
}



int TM::convert_toTexture(
    const SDL_Surface*  surface, 
    SDL_Texture*&       tex
){
    // Create SDL_Texture* ------------------------------------------------------------------------
    tex = SDL_CreateTexture(
        Sys::renderer,
        TextureData::defaultPixelFormat,
        TextureData::defaultAccess,
        surface->w,
        surface->h
    );
    if(tex == nullptr) return TM_TEXTURE_CREATE_ERROR;


    // Cleat the texture to be transparent --------------------------------------------------------
    auto oldTarget = SDL_GetRenderTarget(Sys::renderer);
    SDL_SetRenderTarget(Sys::renderer, tex);

    SDL_SetRenderDrawColor(Sys::renderer, 0, 0, 0, 0);
    SDL_RenderClear(Sys::renderer);

    SDL_SetRenderTarget(Sys::renderer, oldTarget);


    // Set Scale Mode for the Texture -------------------------------------------------------------
    bool err = SDL_SetTextureScaleMode(tex, SDL_SCALEMODE_LINEAR);
    if(!err){
        SDL_DestroyTexture(tex);
        cout << SDL_GetError() << endl;
        return TM_STSM_FAILED;
    }
    

    // Fill the texture with the image data -------------------------------------------------------
    err = SDL_UpdateTexture(tex, NULL, surface->pixels, surface->pitch);
    if(!err){
        SDL_DestroyTexture(tex);
        return TM_TEXTURE_UPDATE_ERROR;
    }
    
    // Make texture Updatable/Modifiable ----------------------------------------------------------
    err = SDL_SetTextureBlendMode(tex, SDL_BLENDMODE_BLEND);
    if(!err){
        SDL_DestroyTexture(tex);
        return TM_TEXTURE_SET_BLENDMODE_ERROR;
    }

    return NO_ERROR;
}




int TM::convert_textureTo(
    const TextureData&  td, 
    SDL_Surface*&       surface
){
    // 1) Remember old render‐target, switch to the texture we want to read
    SDL_Texture* oldTarget = SDL_GetRenderTarget(Sys::renderer);

    bool err = SDL_SetRenderTarget(Sys::renderer, td.getTexture());
    if (!err) {
        return TM_SRT_FAILED;
    }

    // 2) Read *all* pixels from the current render‐target into a new SDL_Surface*
    surface = SDL_RenderReadPixels(Sys::renderer, nullptr);
    // Returns nullptr on failure; must free with SDL_DestroySurface()
    if (!surface) {
        SDL_SetRenderTarget(Sys::renderer, oldTarget);
        return TM_RRP_FAILED;
    }

    // 3) Restore the previous target
    SDL_SetRenderTarget(Sys::renderer, oldTarget);

    return NO_ERROR;
}

int TM::convert_textureTo(
    SDL_Texture*  tex, 
    SDL_Surface*&       surface
){
    // 1) Remember old render‐target, switch to the texture we want to read
    SDL_Texture* oldTarget = SDL_GetRenderTarget(Sys::renderer);

    bool err = SDL_SetRenderTarget(Sys::renderer, tex);
    if (!err) {
        return TM_SRT_FAILED;
    }

    // 2) Read *all* pixels from the current render‐target into a new SDL_Surface*
    surface = SDL_RenderReadPixels(Sys::renderer, nullptr);
    // Returns nullptr on failure; must free with SDL_DestroySurface()
    if (!surface) {
        SDL_SetRenderTarget(Sys::renderer, oldTarget);
        return TM_RRP_FAILED;
    }

    // 3) Restore the previous target
    SDL_SetRenderTarget(Sys::renderer, oldTarget);

    return NO_ERROR;
}


